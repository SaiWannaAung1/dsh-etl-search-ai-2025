```aiignore
You are absolutely right. I missed retaining the ExistsAsync method during the refactoring. In a real-world scenario, you often keep specific high-performance or common queries (like Exists) as direct methods, while using Specifications for flexible querying.

Here is the corrected code for the Interface, Implementation, and the Updated Integration Tests.

1. Corrected Interface (IMetadataRepository.cs)
File: backend/DshEtlSearch.Core/Interfaces/Infrastructure/IMetadataRepository.cs

using DshEtlSearch.Core.Domain;
using DshEtlSearch.Core.Interfaces; // Ensure this namespace exists for ISpecification

namespace DshEtlSearch.Core.Interfaces.Infrastructure
{
    public interface IMetadataRepository
    {
        // --- Standard CRUD ---
        Task<Dataset?> GetByIdAsync(Guid id);
        Task AddAsync(Dataset dataset);
        
        // [RESTORED] Check existence efficiently
        Task<bool> ExistsAsync(string sourceIdentifier);
        
        Task SaveChangesAsync();

        // --- Specification Pattern Methods ---
        Task<Dataset?> GetEntityWithSpec(ISpecification<Dataset> spec);
        Task<IEnumerable<Dataset>> ListAsync(ISpecification<Dataset> spec);
    }
}
2. Corrected Implementation (SqliteMetadataRepository.cs)
File: backend/DshEtlSearch.Infrastructure/Data/SQLite/SqliteMetadataRepository.cs

using DshEtlSearch.Core.Domain;
using DshEtlSearch.Core.Interfaces;
using DshEtlSearch.Core.Interfaces.Infrastructure;
using Microsoft.EntityFrameworkCore;

namespace DshEtlSearch.Infrastructure.Data.SQLite
{
    public class SqliteMetadataRepository : IMetadataRepository
    {
        private readonly AppDbContext _context;

        public SqliteMetadataRepository(AppDbContext context)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));
        }

        public async Task AddAsync(Dataset dataset)
        {
            if (dataset == null) throw new ArgumentNullException(nameof(dataset));
            await _context.Datasets.AddAsync(dataset);
        }

        // [RESTORED] Implementation
        public async Task<bool> ExistsAsync(string sourceIdentifier)
        {
            if (string.IsNullOrWhiteSpace(sourceIdentifier)) return false;
            return await _context.Datasets.AnyAsync(d => d.SourceIdentifier == sourceIdentifier);
        }

        public async Task<Dataset?> GetByIdAsync(Guid id)
        {
            return await _context.Datasets.FindAsync(id);
        }

        public async Task SaveChangesAsync()
        {
            await _context.SaveChangesAsync();
        }

        // --- Specification Evaluator Logic ---

        public async Task<Dataset?> GetEntityWithSpec(ISpecification<Dataset> spec)
        {
            return await ApplySpecification(spec).FirstOrDefaultAsync();
        }

        public async Task<IEnumerable<Dataset>> ListAsync(ISpecification<Dataset> spec)
        {
            return await ApplySpecification(spec).ToListAsync();
        }

        private IQueryable<Dataset> ApplySpecification(ISpecification<Dataset> spec)
        {
            // Applies the criteria (Where) and Includes (Joins) defined in the Spec
            return SpecificationEvaluator<Dataset>.GetQuery(_context.Datasets.AsQueryable(), spec);
        }
    }
}
3. Updated Integration Tests
We need to update the tests to:

Verify ExistsAsync still works.
Verify the new Specification logic works (e.g., retrieving data with Includes).
First, create a dummy Specification inside the test project or referencing one if you made it in Core. For this test, we can define a simple one inside the test file or use the BaseSpecification.

File: backend/DshEtlSearch.IntegrationTests/Infrastructure/Repositories/SqliteMetadataRepositoryTests.cs

using DshEtlSearch.Core.Common;
using DshEtlSearch.Core.Common.Enums;
using DshEtlSearch.Core.Domain;
using DshEtlSearch.Infrastructure.Data.SQLite;
using FluentAssertions;
using Microsoft.Data.Sqlite;
using Microsoft.EntityFrameworkCore;
using Xunit;

namespace DshEtlSearch.IntegrationTests.Infrastructure.Repositories
{
    // Helper Specification for Testing
    public class TestDatasetWithChildrenSpec : BaseSpecification<Dataset>
    {
        public TestDatasetWithChildrenSpec(Guid id) : base(d => d.Id == id)
        {
            AddInclude("Metadata");
            AddInclude("Documents");
        }
    }

    public class SqliteMetadataRepositoryTests : IDisposable
    {
        private readonly SqliteConnection _connection;
        private readonly AppDbContext _context;
        private readonly SqliteMetadataRepository _repository;

        public SqliteMetadataRepositoryTests()
        {
            // 1. Setup In-Memory SQLite
            _connection = new SqliteConnection("DataSource=:memory:");
            _connection.Open();

            var options = new DbContextOptionsBuilder<AppDbContext>()
                .UseSqlite(_connection)
                .Options;

            _context = new AppDbContext(options);
            _context.Database.EnsureCreated();

            _repository = new SqliteMetadataRepository(_context);
        }

        [Fact]
        public async Task AddAsync_ShouldPersist_And_GetEntityWithSpec_ShouldRetrieveIncludes()
        {
            // Arrange
            var dataset = new Dataset("doi:spec-test");
            dataset.Metadata = new MetadataRecord 
            { 
                Title = "Spec Test", 
                // Fix: Providing required fields (nullable or not, good to be safe)
                Authors = "Test Author",
                SourceFormat = MetadataFormat.Iso19115Xml 
            };
            dataset.AddDocument("doc.pdf", FileType.Pdf, 123);

            // Act
            await _repository.AddAsync(dataset);
            await _repository.SaveChangesAsync();
            
            // Clear tracker to force DB fetch
            _context.ChangeTracker.Clear();

            // Act 2: Use Specification
            var spec = new TestDatasetWithChildrenSpec(dataset.Id);
            var result = await _repository.GetEntityWithSpec(spec);

            // Assert
            result.Should().NotBeNull();
            result!.Metadata.Should().NotBeNull(); // Verify Include worked
            result.Metadata.Title.Should().Be("Spec Test");
            result.Documents.Should().HaveCount(1); // Verify Include worked
        }

        [Fact]
        public async Task ExistsAsync_ShouldReturnTrue_WhenDatasetExists()
        {
            // Arrange
            var dataset = new Dataset("doi:exists-check");
            // Minimal required data
            dataset.Metadata = new MetadataRecord { Title = "T", Authors = "A" }; 
            
            await _repository.AddAsync(dataset);
            await _repository.SaveChangesAsync();

            // Act
            var exists = await _repository.ExistsAsync("doi:exists-check");
            var notExists = await _repository.ExistsAsync("doi:fake");

            // Assert
            exists.Should().BeTrue();
            notExists.Should().BeFalse();
        }

        public void Dispose()
        {
            _connection.Close();
            _context.Dispose();
        }
    }
}
Summary of Changes
Interface: Restored ExistsAsync.
Implementation: Restored logic for ExistsAsync and added the ApplySpecification helper.
Tests:
    Added TestDatasetWithChildrenSpec (a tiny class inside the test file) to test the specification logic without relying on the main project's specs.
    Updated AddAsync test to use GetEntityWithSpec instead of GetByIdAsync, proving that the new architecture retrieves related data correctly.
Run the tests now:

dotnet test ./backend/DshEtlSearch.IntegrationTests/DshEtlSearch.IntegrationTests.csproj
```