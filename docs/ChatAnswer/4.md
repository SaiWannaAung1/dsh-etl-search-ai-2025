Here is the explanation of how they are connected. The connection is not a direct wire between the ETL code and the Search code; rather, they are connected by the Shared Storage Layer (the Databases).

The Connection: A "Producer-Consumer" Relationship
* Diagram 1 (The ETL System) is the Producer. It runs in the background (offline) and its only job is to fill the databases.
* Diagram 2 (The Search System) is the Consumer. It runs in real-time (online) and reads from those same databases.

Here is the "Bridge Diagram" that shows exactly where the top diagram connects to the bottom diagram:

```aiignore
(Bottom of Diagram 1: ETL Output)
                     |
                     | 1. WRITE DATA
                     v
   +=========================================+
   |          SHARED STORAGE LAYER           |
   |                                         |
   |  +-------------------+   +------------+ |
   |  |  SQLite Database  |   | Vector Store| |
   |  | (Metadata Tables) |   | (Embeddings)| |
   |  +---------+---------+   +------+-----+ |
   |            ^                    ^       |
   +============|====================|=======+
                |                    |
                | 2. READ DATA       |
                |                    |
      (Middle of Diagram 2: Search Input)
```

Detailed Connection Logic
The two systems are "glued" together using Dataset IDs.
1. The Handover (Step 1 -> Step 2):
   * In Diagram 1: When the ETL process finishes parsing a file (e.g., flood-data-2025.zip), it assigns it a unique ID (e.g., ID: 101) and saves the title/abstract in SQLite. It also saves the vector embedding for that title in the Vector Store, tagging it with ID: 101.
   * In Diagram 2: When the user searches, the Vector Store finds the vector closest to the query and returns ID: 101. The Search Orchestrator then asks SQLite, "Give me the details for ID: 101," to display the title and download link to the user.
2. Why this separation is powerful:
   * Decoupling: You can turn off the ETL system completely, and the Search system will still work perfectly (it just won't see new data).
   * Performance: The user never has to wait for the system to "read" a file. The reading was already done hours ago by Diagram 1.

So, in your final documentation, you can present Diagram 1 as the "Ingestion Subsystem" and Diagram 2 as the "Search Subsystem", with the databases listed as the "Shared Infrastructure" that bridges them.
