To implement the **Search Component** using the **MVVM** pattern in Svelte 5, we will split the code into three distinct files. This ensures the UI (View) is decoupled from the logic (ViewModel) and the data (Model).

### 1. The Model (`src/lib/models/Search.ts`)

This defines the structure of the data coming from your C# backend.

```typescript
export interface DatasetResult {
    id: string;
    title: string;
    abstract: string;
    authors: string;
    score: number; // Vector search similarity score
}

export interface SearchResponse {
    results: DatasetResult[];
    totalCount: number;
    queryTimeMs: number;
}

```

---

### 2. The ViewModel (`src/lib/viewmodels/SearchVM.svelte.ts`)

The ViewModel manages the **reactive state** using Svelte 5 runes and calls the service.

```typescript
import { SearchService } from '$lib/services/SearchService';
import type { DatasetResult } from '$lib/models/Search';

export class SearchVM {
    // Reactive State (Runes)
    query = $state('');
    results = $state<DatasetResult[]>([]);
    isLoading = $state(false);
    errorMessage = $state<string | null>(null);

    // Derived state (automatically updates when results change)
    hasResults = $derived(this.results.length > 0);

    async performSearch() {
        if (!this.query.trim()) return;

        this.isLoading = true;
        this.errorMessage = null;

        try {
            const response = await SearchService.searchDatasets(this.query);
            this.results = response.results;
        } catch (err) {
            this.errorMessage = 'Failed to fetch search results. Please try again.';
            console.error(err);
        } finally {
            this.isLoading = false;
        }
    }

    clearSearch() {
        this.query = '';
        this.results = [];
    }
}

```

---

### 3. The View (`src/routes/search/+page.svelte`)

The View is "dumb." It simply binds its HTML inputs to the ViewModel and iterates over the results.

```svelte
<script lang="ts">
    import { SearchVM } from '$lib/viewmodels/SearchVM.svelte';
    import DatasetCard from '$lib/components/DatasetCard.svelte';

    // Instantiate the ViewModel
    const vm = new SearchVM();
</script>

<div class="container mx-auto p-6">
    <h1 class="text-3xl font-bold mb-6">DshETL Semantic Search</h1>

    <div class="flex gap-2 mb-8">
        <input
            type="text"
            bind:value={vm.query}
            placeholder="Search for datasets (e.g., 'climate change impact')..."
            class="w-full p-3 border rounded-lg shadow-sm focus:ring-2 focus:ring-blue-500"
            onkeydown={(e) => e.key === 'Enter' && vm.performSearch()}
        />
        <button
            onclick={() => vm.performSearch()}
            disabled={vm.isLoading}
            class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 disabled:bg-gray-400"
        >
            {vm.isLoading ? 'Searching...' : 'Search'}
        </button>
    </div>

    {#if vm.errorMessage}
        <div class="text-red-500 bg-red-100 p-4 rounded-md mb-4">
            {vm.errorMessage}
        </div>
    {/if}

    {#if vm.hasResults}
        <div class="grid grid-cols-1 gap-4">
            {#each vm.results as dataset}
                <DatasetCard {dataset} />
            {/each}
        </div>
    {:else if !vm.isLoading && vm.query}
        <p class="text-gray-500">No datasets found for your query.</p>
    {/if}
</div>

```

---

### üìù Why this design is effective for your Project:

* **Decoupled Logic:** If you want to change how the search works (e.g., add debouncing), you only edit `SearchVM.svelte.ts`. The HTML remains untouched.
* **Easy Testing:** You can write a **Vitest** for `SearchVM` without needing to render any Svelte components.
* **Rider Friendly:** Since the logic is in a `.ts` file, Rider‚Äôs code completion and refactoring tools work perfectly.

**Would you like me to generate the `SearchService.ts` code to handle the actual `fetch` call to your C# `/api/search` endpoint?**


