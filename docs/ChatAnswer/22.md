```aiignore

The error SQLite Error 19: 'NOT NULL constraint failed: MetadataRecords.Authors' happens because your Domain Entity (MetadataRecord.cs) defines Authors as a non-nullable string, making it a required field in the database. However, your test setup did not provide a value for it.

You have two options to fix this. I recommend Option 1 for this specific test failure, as it respects the current "strict" validation of your domain.

Option 1: Fix the Integration Test (Recommended)
Update the test setup to provide the missing required fields (Authors and Keywords).

File: backend/DshEtlSearch.IntegrationTests/Infrastructure/Repositories/SqliteMetadataRepositoryTests.cs

Find the AddAsync_ShouldPersistDataset_WithRelationships method and update the MetadataRecord initialization:

[Fact]
public async Task AddAsync_ShouldPersistDataset_WithRelationships()
{
    // Arrange
    var dataset = new Dataset("doi:10.1000/test-data");
    
    // Add Child: Metadata
    dataset.Metadata = new MetadataRecord
    {
        Title = "Integration Test Title",
        Abstract = "Testing persistence...",
        // [FIX] Added required fields to satisfy NOT NULL database constraint
        Authors = "Dr. Test Author, Prof. Data", 
        Keywords = "integration, testing, sqlite",
        SourceFormat = MetadataFormat.Iso19115Xml
    };

    // Add Child: Document
    dataset.AddDocument("report.pdf", FileType.Pdf, 500);

    // ... rest of the test remains the same
Option 2: Make the Domain Flexible (Alternative)
If you believe that Authors or Keywords might naturally be missing in some real-world datasets, you should update your Domain Entity to allow nulls.

File: backend/DshEtlSearch.Core/Domain/MetadataRecord.cs

Change the types from string to string? (nullable):

public class MetadataRecord
{
    // ...
    public string Title { get; set; } // Title likely still required
    public string? Abstract { get; set; } // Optional
    public string? Authors { get; set; }  // Optional
    public string? Keywords { get; set; } // Optional
    // ...
}
If you choose Option 2, you don't need to change the test, but Option 1 is the immediate fix for your current codebase state.
```