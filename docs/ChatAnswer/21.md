```aiignore
We are moving to Task 1.2: Implement SQLite Repository.

Branch: feature/infra-sqlite Goal: Implement the persistence layer using Entity Framework Core (EF Core) to store Datasets and Metadata in a SQLite database.

Step 1: Install Dependencies
Run these commands in your backend folder to add the required Entity Framework Core packages.

# 1. Add EF Core to Infrastructure (The Implementation Layer)
dotnet add DshEtlSearch.Infrastructure/DshEtlSearch.Infrastructure.csproj package Microsoft.EntityFrameworkCore.Sqlite
dotnet add DshEtlSearch.Infrastructure/DshEtlSearch.Infrastructure.csproj package Microsoft.EntityFrameworkCore.Design

# 2. Add EF Core to IntegrationTests (For In-Memory testing)
dotnet add DshEtlSearch.IntegrationTests/DshEtlSearch.IntegrationTests.csproj package Microsoft.EntityFrameworkCore.Sqlite
Step 2: Define the Interface (The Contract)
File: backend/DshEtlSearch.Core/Interfaces/Infrastructure/IMetadataRepository.cs

This defines what operations we need, without knowing how (SQL vs File) they are done.

using DshEtlSearch.Core.Domain;

namespace DshEtlSearch.Core.Interfaces.Infrastructure
{
    public interface IMetadataRepository
    {
        // Commands (Writes)
        Task AddAsync(Dataset dataset);
        Task UpdateAsync(Dataset dataset);
        
        // Queries (Reads)
        Task<Dataset?> GetByIdAsync(Guid id);
        Task<Dataset?> GetBySourceIdentifierAsync(string sourceIdentifier);
        Task<List<Dataset>> GetAllAsync();
        
        // Check existence to prevent duplicates
        Task<bool> ExistsAsync(string sourceIdentifier);
    }
}
Step 3: Implement the Database Context (EF Core)
File: backend/DshEtlSearch.Infrastructure/Data/SQLite/AppDbContext.cs

This maps our C# objects (Dataset, MetadataRecord) to database tables.

using DshEtlSearch.Core.Domain;
using Microsoft.EntityFrameworkCore;

namespace DshEtlSearch.Infrastructure.Data.SQLite
{
    public class AppDbContext : DbContext
    {
        public DbSet<Dataset> Datasets { get; set; }
        public DbSet<MetadataRecord> MetadataRecords { get; set; }
        public DbSet<SupportingDocument> SupportingDocuments { get; set; }

        public AppDbContext(DbContextOptions<AppDbContext> options) : base(options) { }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            // Configure Dataset (Root Aggregate)
            modelBuilder.Entity<Dataset>(entity =>
            {
                entity.HasKey(e => e.Id);
                entity.HasIndex(e => e.SourceIdentifier).IsUnique(); // Ensure unique DOI/ID
                
                // One-to-One with Metadata
                entity.HasOne(d => d.Metadata)
                      .WithOne()
                      .HasForeignKey<MetadataRecord>(m => m.DatasetId)
                      .OnDelete(DeleteBehavior.Cascade);

                // One-to-Many with Documents
                entity.HasMany(d => d.Documents)
                      .WithOne()
                      .HasForeignKey(doc => doc.DatasetId)
                      .OnDelete(DeleteBehavior.Cascade);
                      
                // Ignore Embeddings for SQLite (they go to Vector Store)
                entity.Ignore(e => e.Embeddings);
            });
        }
    }
}
Step 4: Implement the Repository
File: backend/DshEtlSearch.Infrastructure/Data/SQLite/SqliteMetadataRepository.cs

This implements the contract using the Context defined above.

using DshEtlSearch.Core.Domain;
using DshEtlSearch.Core.Interfaces.Infrastructure;
using Microsoft.EntityFrameworkCore;

namespace DshEtlSearch.Infrastructure.Data.SQLite
{
    public class SqliteMetadataRepository : IMetadataRepository
    {
        private readonly AppDbContext _context;

        public SqliteMetadataRepository(AppDbContext context)
        {
            _context = context;
        }

        public async Task AddAsync(Dataset dataset)
        {
            await _context.Datasets.AddAsync(dataset);
            await _context.SaveChangesAsync();
        }

        public async Task UpdateAsync(Dataset dataset)
        {
            _context.Datasets.Update(dataset);
            await _context.SaveChangesAsync();
        }

        public async Task<Dataset?> GetByIdAsync(Guid id)
        {
            return await _context.Datasets
                .Include(d => d.Metadata)
                .Include(d => d.Documents)
                .FirstOrDefaultAsync(d => d.Id == id);
        }

        public async Task<Dataset?> GetBySourceIdentifierAsync(string sourceIdentifier)
        {
            return await _context.Datasets
                .Include(d => d.Metadata)
                .Include(d => d.Documents)
                .FirstOrDefaultAsync(d => d.SourceIdentifier == sourceIdentifier);
        }

        public async Task<List<Dataset>> GetAllAsync()
        {
            return await _context.Datasets
                .Include(d => d.Metadata) // Eager load metadata for list views
                .ToListAsync();
        }

        public async Task<bool> ExistsAsync(string sourceIdentifier)
        {
            return await _context.Datasets.AnyAsync(d => d.SourceIdentifier == sourceIdentifier);
        }
    }
}
Step 5: Integration Test (Verify Persistence)
We will use an In-Memory SQLite connection for testing. This is faster than writing to disk and ensures a clean state for every test run.

File: backend/DshEtlSearch.IntegrationTests/Infrastructure/Repositories/SqliteMetadataRepositoryTests.cs

using DshEtlSearch.Core.Common.Enums;
using DshEtlSearch.Core.Domain;
using DshEtlSearch.Infrastructure.Data.SQLite;
using FluentAssertions;
using Microsoft.Data.Sqlite;
using Microsoft.EntityFrameworkCore;
using Xunit;

namespace DshEtlSearch.IntegrationTests.Infrastructure.Repositories
{
    public class SqliteMetadataRepositoryTests : IDisposable
    {
        private readonly SqliteConnection _connection;
        private readonly DbContextOptions<AppDbContext> _options;

        public SqliteMetadataRepositoryTests()
        {
            // 1. Open a single connection for the duration of the test
            _connection = new SqliteConnection("DataSource=:memory:");
            _connection.Open();

            // 2. Configure EF to use this connection
            _options = new DbContextOptionsBuilder<AppDbContext>()
                .UseSqlite(_connection)
                .Options;

            // 3. Create the Schema (Tables)
            using var context = new AppDbContext(_options);
            context.Database.EnsureCreated();
        }

        [Fact]
        public async Task AddAsync_ShouldPersistDataset_AndRetrieveById()
        {
            // Arrange
            using var context = new AppDbContext(_options);
            var repository = new SqliteMetadataRepository(context);
            
            var dataset = new Dataset("doi:integration-test");
            dataset.Metadata = new MetadataRecord 
            { 
                Title = "Test Title", 
                SourceFormat = MetadataFormat.Iso19115Xml 
            };
            dataset.AddDocument("data.csv", FileType.Unknown, 500);

            // Act
            await repository.AddAsync(dataset);

            // Assert (Use a new context to ensure we are reading from DB, not memory cache)
            using var readContext = new AppDbContext(_options);
            var readRepo = new SqliteMetadataRepository(readContext);
            var result = await readRepo.GetByIdAsync(dataset.Id);

            result.Should().NotBeNull();
            result!.SourceIdentifier.Should().Be("doi:integration-test");
            result.Metadata.Title.Should().Be("Test Title");
            result.Documents.Should().HaveCount(1);
        }

        [Fact]
        public async Task ExistsAsync_ShouldReturnTrue_WhenRecordExists()
        {
            // Arrange
            using var context = new AppDbContext(_options);
            var repository = new SqliteMetadataRepository(context);
            await repository.AddAsync(new Dataset("doi:duplicate-check"));

            // Act
            var exists = await repository.ExistsAsync("doi:duplicate-check");

            // Assert
            exists.Should().BeTrue();
        }

        public void Dispose()
        {
            _connection.Close();
            _connection.Dispose();
        }
    }
}
Step 6: Verify Implementation
Run the Integration Tests to confirm the repository works correctly with SQLite.

dotnet test ./backend/DshEtlSearch.IntegrationTests/DshEtlSearch.IntegrationTests.csproj
If it passes (Green), commit your changes:

git add .
git commit -m "feat: implement sqlite repository and integration tests"
git push origin feature/infra-sqlite
```