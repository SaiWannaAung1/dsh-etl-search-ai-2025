```aiignore
It seems I referenced a helper method DownloadStreamAsync in the previous explanation that might not be exposed or implemented in your version of the interface. That is perfectly fine; the EtlOrchestrator should rely on the specific public methods of the client interface (GetMetadataAsync and DownloadDatasetZipAsync), not generic helpers.

Here is the implementation of the EtlOrchestrator and its Unit Tests.

1. Refined Interface Requirement
Before implementing the Orchestrator, ensure your ICehCatalogueClient interface (in Core) looks like this. These are the specific methods the Orchestrator calls.

File: DshEtlSearch.Core/Interfaces/Infrastructure/ICehCatalogueClient.cs

using DshEtlSearch.Core.Common;
using DshEtlSearch.Core.Common.Enums;

namespace DshEtlSearch.Core.Interfaces.Infrastructure;

public interface ICehCatalogueClient
{
    // Fetches the XML/JSON metadata stream
    Task<Result<Stream>> GetMetadataAsync(string fileIdentifier, MetadataFormat format);

    // Fetches the large data zip stream
    Task<Result<Stream>> DownloadDatasetZipAsync(string fileIdentifier);
}
2. Implement EtlOrchestrator (The "Workflow")
This class orchestrates the flow: Metadata -> Parse -> Zip -> Extract -> Save.

File: DshEtlSearch.Core/Features/Ingestion/EtlOrchestrator.cs

using DshEtlSearch.Core.Common;
using DshEtlSearch.Core.Common.Enums;
using DshEtlSearch.Core.Domain;
using DshEtlSearch.Core.Interfaces.Infrastructure;
using DshEtlSearch.Core.Interfaces.Services;
using DshEtlSearch.Infrastructure.FileProcessing.Parsers; // Dependent on Factory

namespace DshEtlSearch.Core.Features.Ingestion;

public class EtlOrchestrator : IEtlService
{
    private readonly ICehCatalogueClient _cehClient;
    private readonly IArchiveProcessor _archiveProcessor;
    private readonly IMetadataRepository _repository;
    private readonly MetadataParserFactory _parserFactory;

    public EtlOrchestrator(
        ICehCatalogueClient cehClient,
        IArchiveProcessor archiveProcessor,
        IMetadataRepository repository,
        MetadataParserFactory parserFactory)
    {
        _cehClient = cehClient;
        _archiveProcessor = archiveProcessor;
        _repository = repository;
        _parserFactory = parserFactory;
    }

    public async Task<Result> IngestDatasetAsync(string datasetUrl, string fileIdentifier)
    {
        // NOTE: 'datasetUrl' param is kept for interface compatibility, 
        // but for CEH we primarily rely on 'fileIdentifier' to build specific URLs in the client.
        
        try
        {
            // 1. Check if dataset already exists in DB
            if (await _repository.ExistsAsync(fileIdentifier))
            {
                return Result.Failure($"Dataset {fileIdentifier} already exists.");
            }

            // 2. Fetch ISO XML Metadata first (The "Truth")
            var metaResult = await _cehClient.GetMetadataAsync(fileIdentifier, MetadataFormat.Iso19115Xml);
            if (!metaResult.IsSuccess)
            {
                return Result.Failure($"Failed to fetch metadata: {metaResult.Error}");
            }

            // 3. Parse Metadata
            // We need a temporary dataset ID for the parsing result, we'll assign the real one next.
            var tempId = Guid.NewGuid(); 
            var parser = _parserFactory.GetParser(MetadataFormat.Iso19115Xml);
            
            using var metaStream = metaResult.Value!;
            var parseResult = parser.Parse(metaStream, tempId);
            
            if (!parseResult.IsSuccess)
            {
                return Result.Failure($"Failed to parse XML: {parseResult.Error}");
            }

            // 4. Create the Domain Entity
            var dataset = new Dataset(fileIdentifier);
            var metadataRecord = parseResult.Value!;
            
            // Re-link metadata to the correct Dataset ID
            // (Ideally, MetadataRecord setter for DatasetId would be internal or constructor based)
            // For now, we assume EF Core handles the ID link via the object reference below:
            dataset.Metadata = metadataRecord; 

            // 5. Download and Process Zip (Supporting Docs)
            var zipResult = await _cehClient.DownloadDatasetZipAsync(fileIdentifier);
            if (zipResult.IsSuccess)
            {
                using var zipStream = zipResult.Value!;
                var extractResult = await _archiveProcessor.ExtractDocumentsAsync(zipStream, dataset.Id);
                
                if (extractResult.IsSuccess)
                {
                    foreach (var doc in extractResult.Value!)
                    {
                        dataset.AddDocument(doc);
                    }
                }
                else
                {
                    // Warning: We continue even if zip extraction fails, 
                    // because we at least have the metadata.
                    // Log warning here in a real app.
                }
            }
            else
            {
                // Logic for "FileAccess" datasets (non-zip) would go here.
            }

            // 6. Save everything to SQLite
            await _repository.AddAsync(dataset);

            return Result.Success();
        }
        catch (Exception ex)
        {
            return Result.Failure($"ETL Error: {ex.Message}");
        }
    }
}
3. Implement Unit Tests
We use Moq to simulate the external CEH website and the Zip processor. This ensures we test the logic flow without needing an internet connection.

File: tests/DshEtlSearch.Tests.Unit/Core/Features/EtlOrchestratorTests.cs

using DshEtlSearch.Core.Common;
using DshEtlSearch.Core.Common.Enums;
using DshEtlSearch.Core.Domain;
using DshEtlSearch.Core.Features.Ingestion;
using DshEtlSearch.Core.Interfaces.Infrastructure;
using DshEtlSearch.Infrastructure.FileProcessing.Parsers;
using Moq;
using Xunit;

namespace DshEtlSearch.Tests.Unit.Core.Features;

public class EtlOrchestratorTests
{
    private readonly Mock<ICehCatalogueClient> _mockCehClient;
    private readonly Mock<IArchiveProcessor> _mockArchive;
    private readonly Mock<IMetadataRepository> _mockRepo;
    private readonly MetadataParserFactory _parserFactory;
    private readonly EtlOrchestrator _orchestrator;

    public EtlOrchestratorTests()
    {
        _mockCehClient = new Mock<ICehCatalogueClient>();
        _mockArchive = new Mock<IArchiveProcessor>();
        _mockRepo = new Mock<IMetadataRepository>();
        
        // We use the real factory because it contains no external side effects (pure logic)
        _parserFactory = new MetadataParserFactory();

        _orchestrator = new EtlOrchestrator(
            _mockCehClient.Object,
            _mockArchive.Object,
            _mockRepo.Object,
            _parserFactory);
    }

    [Fact]
    public async Task IngestDatasetAsync_ShouldSaveDataset_WhenMetadataAndZipAreValid()
    {
        // Arrange
        string id = "ceh-test-id-123";
        string fakeXml = "<root><gmd:MD_Metadata xmlns:gmd='http://www.isotc211.org/2005/gmd' xmlns:gco='http://www.isotc211.org/2005/gco'><gmd:identificationInfo><gmd:MD_DataIdentification><gmd:citation><gmd:CI_Citation><gmd:title><gco:CharacterString>Test Title</gco:CharacterString></gmd:title></gmd:CI_Citation></gmd:citation><gmd:abstract><gco:CharacterString>Test Abstract</gco:CharacterString></gmd:abstract></gmd:MD_DataIdentification></gmd:identificationInfo></gmd:MD_Metadata></root>";
        
        // 1. Mock: Dataset does NOT exist
        _mockRepo.Setup(r => r.ExistsAsync(id)).ReturnsAsync(false);

        // 2. Mock: GetMetadataAsync returns a valid XML stream
        var xmlStream = new MemoryStream(System.Text.Encoding.UTF8.GetBytes(fakeXml));
        _mockCehClient.Setup(c => c.GetMetadataAsync(id, MetadataFormat.Iso19115Xml))
                      .ReturnsAsync(Result<Stream>.Success(xmlStream));

        // 3. Mock: DownloadDatasetZipAsync returns a valid Zip stream
        var zipStream = new MemoryStream(); // Empty stream is fine for this mock
        _mockCehClient.Setup(c => c.DownloadDatasetZipAsync(id))
                      .ReturnsAsync(Result<Stream>.Success(zipStream));

        // 4. Mock: ArchiveProcessor returns 1 PDF document
        var supportingDocs = new List<SupportingDocument>
        {
            new SupportingDocument(Guid.NewGuid(), "read-me.pdf", FileType.Pdf)
        };
        _mockArchive.Setup(a => a.ExtractDocumentsAsync(zipStream, It.IsAny<Guid>()))
                    .ReturnsAsync(Result<List<SupportingDocument>>.Success(supportingDocs));

        // Act
        var result = await _orchestrator.IngestDatasetAsync("ignored-url", id);

        // Assert
        Assert.True(result.IsSuccess, $"ETL Failed: {result.Error}");

        // Verify: Repository.AddAsync was called with the correct data
        _mockRepo.Verify(r => r.AddAsync(It.Is<Dataset>(d => 
            d.FileIdentifier == id && 
            d.Metadata.Title == "Test Title" &&
            d.SupportingDocuments.Count == 1
        )), Times.Once);
    }

    [Fact]
    public async Task IngestDatasetAsync_ShouldFail_WhenMetadataRequestFails()
    {
        // Arrange
        string id = "missing-id";
        _mockRepo.Setup(r => r.ExistsAsync(id)).ReturnsAsync(false);

        // Mock: Metadata fails (404)
        _mockCehClient.Setup(c => c.GetMetadataAsync(id, MetadataFormat.Iso19115Xml))
                      .ReturnsAsync(Result<Stream>.Failure("404 Not Found"));

        // Act
        var result = await _orchestrator.IngestDatasetAsync("ignored", id);

        // Assert
        Assert.False(result.IsSuccess);
        Assert.Contains("Failed to fetch metadata", result.Error);
        
        // Verify: We never tried to download zip or save to DB
        _mockCehClient.Verify(c => c.DownloadDatasetZipAsync(It.IsAny<string>()), Times.Never);
        _mockRepo.Verify(r => r.AddAsync(It.IsAny<Dataset>()), Times.Never);
    }

    [Fact]
    public async Task IngestDatasetAsync_ShouldSkip_IfDatasetAlreadyExists()
    {
        // Arrange
        string id = "existing-id";
        _mockRepo.Setup(r => r.ExistsAsync(id)).ReturnsAsync(true);

        // Act
        var result = await _orchestrator.IngestDatasetAsync("ignored", id);

        // Assert
        Assert.False(result.IsSuccess);
        Assert.Contains("already exists", result.Error);

        // Verify: Nothing called
        _mockCehClient.Verify(c => c.GetMetadataAsync(It.IsAny<string>(), It.IsAny<MetadataFormat>()), Times.Never);
    }
}
This Orchestrator implementation now accurately reflects the business logic: "Metadata is mandatory, Zip is optional but preferred, and we map everything to a Domain Entity before saving." The tests verify this flow rigorously.
```