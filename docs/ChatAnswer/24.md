```aiignore
Yes, you absolutely should use the Specification Pattern. You have correctly identified a common pitfall in Clean Architecture: the "Exploding Repository" problem.

Without Specifications, as your application grows, your IMetadataRepository will end up with dozens of specific methods like:

    GetByDateAsync(...)
    GetByStatusAsync(...)
    GetByAuthorAndDateAsync(...)
    
This violates the Open/Closed Principle because you have to modify the Repository class every time you need a new query filter.

The Solution: Specification Pattern
Instead of writing new methods in the repository, you write small, reusable "Specification" classes that define the logic of the query. The Repository stays generic and "thin."

Here is the implementation plan to refactor your current code.

Step 1: Create a New Branch
Since this is a refactoring of the architecture, do this on a separate branch.

git checkout develop
git checkout -b refactor/specification-pattern
Step 2: Define the Core Interfaces
We need a contract that describes "what" we want to query (Where, Includes, OrderBy).

File: backend/DshEtlSearch.Core/Interfaces/ISpecification.cs

using System.Linq.Expressions;

namespace DshEtlSearch.Core.Interfaces
{
    public interface ISpecification<T>
    {
        // The "Where" clause (e.g., x => x.Id == id)
        Expression<Func<T, bool>> Criteria { get; }
        
        // The "Include" strings (e.g., "Metadata", "Documents")
        List<string> IncludeStrings { get; }
    }
}
File: backend/DshEtlSearch.Core/Common/BaseSpecification.cs This is a helper class so you don't have to implement the interface manually every time.

using System.Linq.Expressions;
using DshEtlSearch.Core.Interfaces;

namespace DshEtlSearch.Core.Common
{
    public abstract class BaseSpecification<T> : ISpecification<T>
    {
        public Expression<Func<T, bool>> Criteria { get; }
        public List<string> IncludeStrings { get; } = new List<string>();

        protected BaseSpecification(Expression<Func<T, bool>> criteria)
        {
            Criteria = criteria;
        }

        // Helper to add "Include" statements easily
        protected void AddInclude(string includeString)
        {
            IncludeStrings.Add(includeString);
        }
    }
}
Step 3: Implement the "Evaluator" (Infrastructure)
This is the magic class that translates your generic ISpecification into specific Entity Framework Core commands (IQueryable).

File: backend/DshEtlSearch.Infrastructure/Data/SpecificationEvaluator.cs

using DshEtlSearch.Core.Interfaces;
using Microsoft.EntityFrameworkCore;

namespace DshEtlSearch.Infrastructure.Data
{
    public class SpecificationEvaluator<T> where T : class
    {
        public static IQueryable<T> GetQuery(IQueryable<T> inputQuery, ISpecification<T> specification)
        {
            var query = inputQuery;

            // 1. Apply Filtering (Where)
            if (specification.Criteria != null)
            {
                query = query.Where(specification.Criteria);
            }

            // 2. Apply Includes (Joins)
            // Aggregate is a fancy LINQ way to loop and apply .Include()
            query = specification.IncludeStrings.Aggregate(query,
                (current, include) => current.Include(include));

            return query;
        }
    }
}
Step 4: Refactor the Repository Interface
Update your interface to accept specifications instead of hardcoded logic.

File: backend/DshEtlSearch.Core/Interfaces/Infrastructure/IMetadataRepository.cs

using DshEtlSearch.Core.Domain;
using DshEtlSearch.Core.Interfaces; // Add this using

namespace DshEtlSearch.Core.Interfaces.Infrastructure
{
    public interface IMetadataRepository
    {
        Task<Dataset?> GetByIdAsync(Guid id);
        Task AddAsync(Dataset dataset);
        Task SaveChangesAsync();

        // NEW: The Generic Method
        Task<Dataset?> GetEntityWithSpec(ISpecification<Dataset> spec);
        Task<IEnumerable<Dataset>> ListAsync(ISpecification<Dataset> spec);
    }
}
Step 5: Refactor the Repository Implementation
Update the repository to use the SpecificationEvaluator.

File: backend/DshEtlSearch.Infrastructure/Data/SQLite/SqliteMetadataRepository.cs

using DshEtlSearch.Core.Domain;
using DshEtlSearch.Core.Interfaces;
using DshEtlSearch.Core.Interfaces.Infrastructure;
using Microsoft.EntityFrameworkCore;

namespace DshEtlSearch.Infrastructure.Data.SQLite
{
    public class SqliteMetadataRepository : IMetadataRepository
    {
        private readonly AppDbContext _context;

        public SqliteMetadataRepository(AppDbContext context)
        {
            _context = context;
        }

        // Existing methods...
        public async Task AddAsync(Dataset dataset) => await _context.Datasets.AddAsync(dataset);
        public async Task SaveChangesAsync() => await _context.SaveChangesAsync();
        public async Task<Dataset?> GetByIdAsync(Guid id) => await _context.Datasets.FindAsync(id);

        // --- NEW IMPLEMENTATION ---
        
        public async Task<Dataset?> GetEntityWithSpec(ISpecification<Dataset> spec)
        {
            return await ApplySpecification(spec).FirstOrDefaultAsync();
        }

        public async Task<IEnumerable<Dataset>> ListAsync(ISpecification<Dataset> spec)
        {
            return await ApplySpecification(spec).ToListAsync();
        }

        private IQueryable<Dataset> ApplySpecification(ISpecification<Dataset> spec)
        {
            // Pass the DbSet (Datasets) into the Evaluator
            return SpecificationEvaluator<Dataset>.GetQuery(_context.Datasets.AsQueryable(), spec);
        }
    }
}
Step 6: Example Usage (How you use it now)
Now, whenever you need a specific query, you just create a class in Core. You never touch the Repository or Controller again for queries.

Example File: backend/DshEtlSearch.Core/Specifications/DatasetWithMetadataSpec.cs

using DshEtlSearch.Core.Common;
using DshEtlSearch.Core.Domain;

namespace DshEtlSearch.Core.Specifications
{
    public class DatasetWithMetadataSpec : BaseSpecification<Dataset>
    {
        public DatasetWithMetadataSpec(string sourceIdentifier) 
            : base(d => d.SourceIdentifier == sourceIdentifier)
        {
            AddInclude("Metadata");
            AddInclude("Documents");
        }
    }
}
Usage in code:

var spec = new DatasetWithMetadataSpec("doi:123");
var dataset = await _repository.GetEntityWithSpec(spec);
Summary of Benefits
Reusability: You can use the same DatasetWithMetadataSpec in your Unit Tests, Controllers, and Background Services.
Clean Repository: Your repository class stays small, even if you have 100 different query types.
Testing: You can unit test the Specification classes (e.g., "Does this spec include Metadata?") without spinning up a database.
```