In a .NET 8 Web API, managing high-resource objects like the **GoogleDriveService** (which handles authentication/connections) and **OnnxEmbeddingService** (which loads a heavy ML model into memory) is best handled via the **Dependency Injection (DI) Container**.

If you instantiate these using `new` inside your loops or services, you will cause memory leaks and high CPU spikes because the ONNX model is re-loaded every time.

### 1. The Architectural Solution: `AddSingleton`

Instead of creating the objects manually, you register them in `Program.cs` as Singletons. This ensures the .NET runtime creates **one instance** and reuses it for the entire life of the application.

#### Step A: Register in `Program.cs`

Open your backend `Program.cs` file and add these lines before `builder.Build()`:

```csharp
// 1. Register Google Drive as a Singleton
// This reuses the same Service Account connection
builder.Services.AddSingleton<IGoogleDriveService, GoogleDriveService>();

// 2. Register ONNX Embedding as a Singleton 
// This is CRITICAL: It loads the model.onnx file ONLY ONCE
builder.Services.AddSingleton<IEmbeddingService, OnnxEmbeddingService>();

// 3. Register your Orchestrator (usually Scoped or Singleton)
builder.Services.AddScoped<EtlOrchestrator>();

```

---

### 2. Implementation: Constructor Injection

Now, update your **EtlOrchestrator** to "ask" for these services through the constructor. You no longer use the `new` keyword.

```csharp
public class EtlOrchestrator
{
    private readonly IGoogleDriveService _googleDrive;
    private readonly IEmbeddingService _embeddingService;

    // .NET will automatically pass the Singleton instances here
    public EtlOrchestrator(
        IGoogleDriveService googleDrive, 
        IEmbeddingService embeddingService)
    {
        _googleDrive = googleDrive;
        _embeddingService = embeddingService;
    }

    public async Task IngestAsync(Stream fileStream)
    {
        // Use the singleton instance
        var vector = await _embeddingService.GenerateEmbeddingAsync("some text");
        await _googleDrive.UploadFileAsync(fileStream, "data.xml", "application/xml", "folder_id");
    }
}

```

---

### 3. Why Singleton is Mandatory for ONNX

The **OnnxEmbeddingService** is a "Heavy Object."

* **Without Singleton:** Every time a file is downloaded, the system reads `model.onnx` from the disk (45MB+), parses the graph, and allocates RAM. If you process 100 files, your RAM will crash.
* **With Singleton:** The model is loaded into the **LOH (Large Object Heap)** once. Subsequent calls to `GenerateEmbeddingAsync` are purely mathematical calculations on the existing model in memory.

---

### 4. Handling Google Drive Auth in Singleton

Since the Google Drive service is a Singleton, you should initialize the `DriveService` (the Google API object) in its constructor so that authentication happens only once.

```csharp
public class GoogleDriveService : IGoogleDriveService
{
    private readonly DriveService _service;

    public GoogleDriveService(IConfiguration config)
    {
        // Authenticate once during app startup
        var credential = GoogleCredential.FromFile("google-drive-key.json")
                            .CreateScoped(DriveService.Scope.DriveFile);

        _service = new DriveService(new BaseClientService.Initializer
        {
            HttpClientInitializer = credential,
            ApplicationName = "DshETL-Search-AI"
        });
    }

    public async Task<Result<string>> UploadFileAsync(Stream stream, ...)
    {
        // Re-use the authenticated _service object
        var request = _service.Files.Create(fileMetadata, stream, contentType);
        var progress = await request.UploadAsync();
        return Result<string>.Success(request.ResponseBody.Id);
    }
}

```


