In a Svelte 5 MVVM architecture, **End-to-End (E2E) testing** is the final layer of your quality strategy. While Unit tests check your "Brain" (ViewModel) and Integration tests check your "Bones" (Components), E2E tests check the "User's Experience" by driving a real browser.

For your project, **Playwright** is the best tool because it handles the asynchronous nature of AI-generated chat and vector search results perfectly.

---

### 1. The E2E Test Strategy

An E2E test for your system should verify the **Full Circle**:

1. The User types a query.
2. The Frontend calls the .NET Backend.
3. The Backend queries Qdrant/SQLite.
4. The Frontend displays the results.

---

### 2. Writing a Search E2E Test

**File:** `tests/search.spec.ts`

This test simulates a real user performing a semantic search and verifies that results appear on the screen.

```typescript
import { test, expect } from '@playwright/test';

test.describe('Search Functionality', () => {
    
    test('should return results for a valid semantic query', async ({ page }) => {
        // 1. Navigate to the search page
        await page.goto('/search');

        // 2. Type into the search input
        const searchInput = page.getByPlaceholder(/Search for datasets/i);
        await searchInput.fill('climate change impacts');

        // 3. Click the search button
        await page.getByRole('button', { name: /Search/i }).click();

        // 4. Wait for the API call and UI update
        // We look for the "DatasetCard" elements
        const results = page.locator('.dataset-card'); // Assuming you have this class
        
        // Assert: At least one result should appear within 10 seconds
        await expect(results.first()).toBeVisible({ timeout: 10000 });
        
        // Assert: Check if the title is relevant
        await expect(page.locator('h3')).toContainText(/climate/i);
    });
});

```

---

### 3. Writing a Chat E2E Test (Conversational)

**File:** `tests/chat.spec.ts`

This test verifies that the **Chat History** logic you just implemented actually works in the browser.

```typescript
import { test, expect } from '@playwright/test';

test('should remember conversation context', async ({ page }) => {
    await page.goto('/chat');

    const input = page.getByPlaceholder(/Ask about your datasets/i);
    const sendBtn = page.getByRole('button', { name: /Send/i });

    // Turn 1: Initial Question
    await input.fill('List 3 datasets about water.');
    await sendBtn.click();

    // Wait for AI response bubble
    await expect(page.locator('.assistant-message')).toBeVisible();

    // Turn 2: Follow-up (Testing History)
    await input.fill('Which one is the most recent?');
    await sendBtn.click();

    // Assert: The AI should provide an answer based on the previous turn
    const lastResponse = page.locator('.assistant-message').last();
    await expect(lastResponse).not.toBeEmpty();
});

```

---

### 4. Running the Tests in Rider

1. **Start your Backend:** Ensure your .NET API is running (Playwright will talk to it).
2. **Start your Frontend:** Run `npm run dev`.
3. **Execute Playwright:**
* **Headed (See the browser):** `npx playwright test --headed`
* **UI Mode (Best for debugging):** `npx playwright test --ui`



---

### 5. Integration with GitHub Actions

In the GitHub Action workflow we created earlier, the **Step 3 (Frontend Testing)** will execute these tests in a "Headless" environment.

#### **Key Pro Tip: BaseURL**

Ensure your `playwright.config.ts` has the correct `webServer` config so GitHub Actions knows how to start your app before testing:

```typescript
// playwright.config.ts
export default defineConfig({
  use: {
    baseURL: 'http://localhost:5173', // Your Svelte dev port
  },
  webServer: {
    command: 'npm run dev',
    url: 'http://localhost:5173',
    reuseExistingServer: !process.env.CI,
  },
});

```

**Would you like me to show you how to use "Playwright Trace Viewer" to see a video recording of exactly why a test failed in GitHub Actions?**


