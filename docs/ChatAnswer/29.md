```aiignore
This task bridges the gap between the external world (CEH Data) and your internal system. We will implement robust file handling, specifically focusing on Streams to keep memory usage low, rather than loading huge files entirely into RAM.

Branch: feature/download-extract

Step 1: Create the Branch
git checkout develop
git checkout -b feature/download-extract
Step 2: Define Interfaces (Core Layer)
We decouple the "What" from the "How".

File: backend/DshEtlSearch.Core/Interfaces/Infrastructure/IDownloader.cs

using DshEtlSearch.Core.Common;

namespace DshEtlSearch.Core.Interfaces.Infrastructure
{
    public interface IDownloader
    {
        /// <summary>
        /// Downloads a file from a URL as a stream.
        /// Useful for processing large files without loading them fully into memory.
        /// </summary>
        Task<Result<Stream>> DownloadStreamAsync(string url);
    }
}
File: backend/DshEtlSearch.Core/Interfaces/Infrastructure/IExtractionService.cs

using DshEtlSearch.Core.Common;

namespace DshEtlSearch.Core.Interfaces.Infrastructure
{
    public interface IExtractionService
    {
        /// <summary>
        /// Extracts a ZIP archive stream to a specified folder.
        /// </summary>
        /// <returns>A list of full paths to the extracted files.</returns>
        Task<Result<List<string>>> ExtractZipAsync(Stream zipStream, string outputFolder);
    }
}
Step 3: Implement Downloader (Infrastructure Layer)
We use IHttpClientFactory for efficient socket management.

File: backend/DshEtlSearch.Infrastructure/FileProcessing/Downloader/CehDatasetDownloader.cs

using DshEtlSearch.Core.Common;
using DshEtlSearch.Core.Interfaces.Infrastructure;
using Microsoft.Extensions.Logging;

namespace DshEtlSearch.Infrastructure.FileProcessing.Downloader
{
    public class CehDatasetDownloader : IDownloader
    {
        private readonly HttpClient _httpClient;
        private readonly ILogger<CehDatasetDownloader> _logger;

        public CehDatasetDownloader(HttpClient httpClient, ILogger<CehDatasetDownloader> logger)
        {
            _httpClient = httpClient;
            _logger = logger;
            // Best Practice: Configure User-Agent to avoid being blocked by some servers
            _httpClient.DefaultRequestHeaders.UserAgent.ParseAdd("DshEtlSearch/1.0");
        }

        public async Task<Result<Stream>> DownloadStreamAsync(string url)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(url))
                    return Result<Stream>.Failure("Download URL cannot be empty.");

                _logger.LogInformation("Starting download from {Url}", url);

                // Use HttpCompletionOption.ResponseHeadersRead to avoid buffering the whole file
                var response = await _httpClient.GetAsync(url, HttpCompletionOption.ResponseHeadersRead);
                
                if (!response.IsSuccessStatusCode)
                {
                    return Result<Stream>.Failure($"Download failed with Status Code: {response.StatusCode}");
                }

                var stream = await response.Content.ReadAsStreamAsync();
                return Result<Stream>.Success(stream);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error downloading from {Url}", url);
                return Result<Stream>.Failure($"Download exception: {ex.Message}");
            }
        }
    }
}
Step 4: Implement Zip Extraction (Infrastructure Layer)
Security Note: We must prevent "Zip Slip" attacks, where a malicious zip file contains relative paths (e.g., ../../system32) to overwrite system files.

File: backend/DshEtlSearch.Infrastructure/FileProcessing/Extractor/ZipExtractionService.cs

using System.IO.Compression;
using DshEtlSearch.Core.Common;
using DshEtlSearch.Core.Interfaces.Infrastructure;
using Microsoft.Extensions.Logging;

namespace DshEtlSearch.Infrastructure.FileProcessing.Extractor
{
    public class ZipExtractionService : IExtractionService
    {
        private readonly ILogger<ZipExtractionService> _logger;

        public ZipExtractionService(ILogger<ZipExtractionService> logger)
        {
            _logger = logger;
        }

        public async Task<Result<List<string>>> ExtractZipAsync(Stream zipStream, string outputFolder)
        {
            var extractedFiles = new List<string>();

            try
            {
                if (!Directory.Exists(outputFolder))
                    Directory.CreateDirectory(outputFolder);

                // 'using' ensures the archive is properly closed after operation
                using var archive = new ZipArchive(zipStream, ZipArchiveMode.Read);
                
                foreach (var entry in archive.Entries)
                {
                    // Skip directories
                    if (string.IsNullOrEmpty(entry.Name)) continue;

                    // 1. Construct Full Path
                    string destinationPath = Path.Combine(outputFolder, entry.FullName);
                    string fullOutputFolder = Path.GetFullPath(outputFolder);

                    // 2. Security Check: Zip Slip Vulnerability
                    // Ensure the final path is actually INSIDE the output folder
                    if (!Path.GetFullPath(destinationPath).StartsWith(fullOutputFolder, StringComparison.Ordinal))
                    {
                        _logger.LogWarning("Zip Slip attempt detected: {EntryName}", entry.FullName);
                        continue; 
                    }

                    // 3. Ensure directory exists for nested files
                    var directoryName = Path.GetDirectoryName(destinationPath);
                    if (!string.IsNullOrEmpty(directoryName))
                        Directory.CreateDirectory(directoryName);

                    // 4. Extract
                    entry.ExtractToFile(destinationPath, overwrite: true);
                    extractedFiles.Add(destinationPath);
                }

                return Result<List<string>>.Success(extractedFiles);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to extract zip archive.");
                return Result<List<string>>.Failure($"Extraction failed: {ex.Message}");
            }
        }
    }
}
Step 5: Testing
We need two types of tests here:

Integration Test (Zip): Verifies that a real zip file is extracted to the disk correctly.
Unit Test (Downloader): Verifies the HTTP logic (we mock the HTTP handler because we don't want to hit real internet URLs during unit tests).
Pre-requisite: Install Mocking for Http
For the Unit Test, we need Moq.Contrib.HttpClient to easily mock HttpClient.

dotnet add backend/DshEtlSearch.UnitTests/DshEtlSearch.UnitTests.csproj package Moq.Contrib.HttpClient
A. Zip Extraction Integration Test
File: backend/DshEtlSearch.IntegrationTests/ExternalServices/ZipExtractionServiceTests.cs

using System.IO.Compression;
using DshEtlSearch.Infrastructure.FileProcessing.Extractor;
using FluentAssertions;
using Microsoft.Extensions.Logging.Abstractions;
using Xunit;

namespace DshEtlSearch.IntegrationTests.ExternalServices
{
    public class ZipExtractionServiceTests : IDisposable
    {
        private readonly string _testFolder;
        private readonly ZipExtractionService _service;

        public ZipExtractionServiceTests()
        {
            _testFolder = Path.Combine(Path.GetTempPath(), "DshIntegrationTests_" + Guid.NewGuid());
            _service = new ZipExtractionService(new NullLogger<ZipExtractionService>());
        }

        [Fact]
        public async Task ExtractZipAsync_ShouldExtractFiles_ToDisk()
        {
            // Arrange: Create a real ZIP in memory
            using var memoryStream = new MemoryStream();
            using (var archive = new ZipArchive(memoryStream, ZipArchiveMode.Create, true))
            {
                var file = archive.CreateEntry("test.txt");
                using var entryStream = file.Open();
                using var writer = new StreamWriter(entryStream);
                writer.Write("Hello Integration Test");
            }
            memoryStream.Position = 0; // Reset stream for reading

            // Act
            var result = await _service.ExtractZipAsync(memoryStream, _testFolder);

            // Assert
            result.IsSuccess.Should().BeTrue();
            result.Value.Should().HaveCount(1);
            File.Exists(Path.Combine(_testFolder, "test.txt")).Should().BeTrue();
            File.ReadAllText(Path.Combine(_testFolder, "test.txt")).Should().Be("Hello Integration Test");
        }

        public void Dispose()
        {
            if (Directory.Exists(_testFolder))
                Directory.Delete(_testFolder, true);
        }
    }
}
B. Downloader Unit Test
File: backend/DshEtlSearch.UnitTests/Infrastructure/Downloader/CehDatasetDownloaderTests.cs

using System.Net;
using DshEtlSearch.Infrastructure.FileProcessing.Downloader;
using FluentAssertions;
using Microsoft.Extensions.Logging.Abstractions;
using Moq;
using Moq.Protected;
using Xunit;

namespace DshEtlSearch.UnitTests.Infrastructure.Downloader
{
    public class CehDatasetDownloaderTests
    {
        [Fact]
        public async Task DownloadStreamAsync_ShouldReturnStream_WhenResponseIsOk()
        {
            // Arrange
            var handlerMock = new Mock<HttpMessageHandler>();
            var content = "File Content";
            
            handlerMock
                .Protected()
                .Setup<Task<HttpResponseMessage>>(
                    "SendAsync",
                    ItExpr.IsAny<HttpRequestMessage>(),
                    ItExpr.IsAny<CancellationToken>()
                )
                .ReturnsAsync(new HttpResponseMessage
                {
                    StatusCode = HttpStatusCode.OK,
                    Content = new StringContent(content)
                });

            var httpClient = new HttpClient(handlerMock.Object);
            var downloader = new CehDatasetDownloader(httpClient, new NullLogger<CehDatasetDownloader>());

            // Act
            var result = await downloader.DownloadStreamAsync("http://example.com/file.zip");

            // Assert
            result.IsSuccess.Should().BeTrue();
            result.Value.Should().NotBeNull();
            
            using var reader = new StreamReader(result.Value!);
            var text = await reader.ReadToEndAsync();
            text.Should().Be(content);
        }

        [Fact]
        public async Task DownloadStreamAsync_ShouldFail_WhenResponseIsError()
        {
            // Arrange
            var handlerMock = new Mock<HttpMessageHandler>();
            handlerMock
                .Protected()
                .Setup<Task<HttpResponseMessage>>(
                    "SendAsync",
                    ItExpr.IsAny<HttpRequestMessage>(),
                    ItExpr.IsAny<CancellationToken>()
                )
                .ReturnsAsync(new HttpResponseMessage
                {
                    StatusCode = HttpStatusCode.NotFound
                });

            var httpClient = new HttpClient(handlerMock.Object);
            var downloader = new CehDatasetDownloader(httpClient, new NullLogger<CehDatasetDownloader>());

            // Act
            var result = await downloader.DownloadStreamAsync("http://example.com/missing.zip");

            // Assert
            result.IsSuccess.Should().BeFalse();
            result.Error.Should().Contain("NotFound");
        }
    }
}
Step 6: Run Tests
Run both Unit and Integration tests to verify the implementation.

dotnet test ./backend/DshEtlSearch.sln
If everything is Green, you can commit and proceed. This completes Task 1.4.
```