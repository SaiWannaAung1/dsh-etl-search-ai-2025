```aiignore
Task 1.1: Implement Domain Entities & Enums Branch: feature/core-domain Goal: Define the pure data structures that the rest of the system will use.

Here is the complete code for the files in DshEtlSearch.Core.

1. Enums (DshEtlSearch.Core/Common/Enums/)
MetadataFormat.cs Defines the types of metadata we support.

namespace DshEtlSearch.Core.Common.Enums
{
    public enum MetadataFormat
    {
        Iso19115Xml,        // Industry Standard
        JsonExpanded,       // Custom Relationship Model
        SchemaOrgJsonLd,    // Web Standard
        RdfTurtle           // Semantic Web
    }
}
FileType.cs Defines file types for safe handling.

namespace DshEtlSearch.Core.Common.Enums
{
    public enum FileType
    {
        Unknown,
        Xml,
        Json,
        Pdf,
        Zip,
        Txt
    }
}
2. Common Wrapper (DshEtlSearch.Core/Common/)
Result.cs A simple wrapper to avoid throwing Exceptions for expected logic failures (Functional C# style).

namespace DshEtlSearch.Core.Common
{
    public class Result<T>
    {
        public bool IsSuccess { get; }
        public T Value { get; }
        public string Error { get; }

        private Result(bool isSuccess, T value, string error)
        {
            IsSuccess = isSuccess;
            Value = value;
            Error = error;
        }

        public static Result<T> Success(T value) => new Result<T>(true, value, null);
        public static Result<T> Failure(string error) => new Result<T>(false, default, error);
    }
    
    // Non-generic version for void methods
    public class Result
    {
        public bool IsSuccess { get; }
        public string Error { get; }

        private Result(bool isSuccess, string error)
        {
            IsSuccess = isSuccess;
            Error = error;
        }

        public static Result Success() => new Result(true, null);
        public static Result Failure(string error) => new Result(false, error);
    }
}
3. Domain Entities (DshEtlSearch.Core/Domain/)
Dataset.cs The Root Aggregate. It holds the "Master Record."

using DshEtlSearch.Core.Common.Enums;

namespace DshEtlSearch.Core.Domain
{
    public class Dataset
    {
        public Guid Id { get; private set; }
        public string SourceIdentifier { get; private set; } // e.g., "doi:10.5285/..."
        public DateTime IngestedAt { get; private set; }
        
        // Navigation Properties
        public MetadataRecord Metadata { get; set; }
        public List<SupportingDocument> Documents { get; private set; } = new();
        public List<EmbeddingVector> Embeddings { get; private set; } = new();

        public Dataset(string sourceIdentifier)
        {
            Id = Guid.NewGuid();
            SourceIdentifier = sourceIdentifier ?? throw new ArgumentNullException(nameof(sourceIdentifier));
            IngestedAt = DateTime.UtcNow;
        }

        // Domain Method: Link a document
        public void AddDocument(string fileName, FileType type, long sizeBytes)
        {
            Documents.Add(new SupportingDocument(Id, fileName, type, sizeBytes));
        }
    }
}
MetadataRecord.cs The unified view of the extracted data.

using DshEtlSearch.Core.Common.Enums;

namespace DshEtlSearch.Core.Domain
{
    public class MetadataRecord
    {
        public Guid Id { get; set; }
        public Guid DatasetId { get; set; } // Foreign Key
        
        public string Title { get; set; }
        public string Abstract { get; set; }
        public string Authors { get; set; } // Comma separated or JSON array
        public DateTime? PublishedDate { get; set; }
        public string Keywords { get; set; } // Comma separated
        
        public MetadataFormat SourceFormat { get; set; }
        
        // Helper to combine text for embedding generation
        public string ToEmbeddingText()
        {
            return $"Title: {Title}\nAbstract: {Abstract}\nKeywords: {Keywords}";
        }
    }
}
SupportingDocument.cs Represents a physical file inside the dataset (e.g., a PDF report).

using DshEtlSearch.Core.Common.Enums;

namespace DshEtlSearch.Core.Domain
{
    public class SupportingDocument
    {
        public Guid Id { get; private set; }
        public Guid DatasetId { get; private set; }
        
        public string FileName { get; private set; }
        public FileType Type { get; private set; }
        public long SizeBytes { get; private set; }
        public string StoragePath { get; set; } // Path in blob storage/disk

        public SupportingDocument(Guid datasetId, string fileName, FileType type, long sizeBytes)
        {
            Id = Guid.NewGuid();
            DatasetId = datasetId;
            FileName = fileName;
            Type = type;
            SizeBytes = sizeBytes;
        }
    }
}
EmbeddingVector.cs Represents the vector data for Qdrant.

namespace DshEtlSearch.Core.Domain
{
    public class EmbeddingVector
    {
        public Guid Id { get; set; }
        public Guid DatasetId { get; set; }
        
        // The actual vector (e.g., 1536 dims for OpenAI)
        // Stored as JSON string or float array depending on DB choice
        public float[] VectorData { get; set; } 
        public int Dimensions { get; set; }
        
        public string ChunkText { get; set; } // The actual text segment this vector represents

        public EmbeddingVector(Guid datasetId, float[] vectorData, string chunkText)
        {
            Id = Guid.NewGuid();
            DatasetId = datasetId;
            VectorData = vectorData;
            Dimensions = vectorData.Length;
            ChunkText = chunkText;
        }
    }
}
```