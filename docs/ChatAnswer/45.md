To test the **Search Component** properly in an MVVM architecture, we separate the tests into two categories: **Unit Tests** (testing the logic inside the ViewModel in isolation) and **Integration Tests** (testing the Component rendering and its interaction with the ViewModel).

---

### 1. Unit Test: ViewModel Logic

**File:** `src/lib/viewmodels/SearchVM.test.ts`

This test focuses on the "Brain" of the component. We mock the `SearchService` so we don't make real API calls, allowing us to test how the ViewModel handles loading states, success, and errors.

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { SearchVM } from './SearchVM.svelte';
import { SearchService } from '$lib/services/SearchService';

// Mock the Service layer
vi.mock('$lib/services/SearchService');

describe('SearchVM Unit Tests', () => {
    let vm: SearchVM;

    beforeEach(() => {
        vm = new SearchVM();
        vi.clearAllMocks();
    });

    it('should initialize with empty state', () => {
        expect(vm.query).toBe('');
        expect(vm.results).toEqual([]);
        expect(vm.isLoading).toBe(false);
    });

    it('should update results and loading state on successful search', async () => {
        const mockResponse = {
            results: [{ id: '1', title: 'Climate Data', abstract: '...', authors: 'AI', score: 0.9 }],
            totalCount: 1,
            queryTimeMs: 10
        };

        (SearchService.searchDatasets as any).mockResolvedValue(mockResponse);

        vm.query = 'climate';
        const searchPromise = vm.performSearch();

        expect(vm.isLoading).toBe(true); // Should be loading immediately
        await searchPromise;

        expect(vm.results).toHaveLength(1);
        expect(vm.results[0].title).toBe('Climate Data');
        expect(vm.isLoading).toBe(false);
    });

    it('should handle errors gracefully', async () => {
        (SearchService.searchDatasets as any).mockRejectedValue(new Error('API Down'));

        vm.query = 'test';
        await vm.performSearch();

        expect(vm.errorMessage).toContain('Failed to fetch');
        expect(vm.isLoading).toBe(false);
        expect(vm.results).toEqual([]);
    });
});

```

---

### 2. Integration Test: View + ViewModel

**File:** `src/routes/search/SearchComponent.test.ts`

This test uses **Svelte Testing Library** to verify that the UI correctly reflects the ViewModel's state and that user interactions (clicking the button) trigger the correct logic.

```typescript
import { render, screen, fireEvent } from '@testing-library/svelte';
import { describe, it, expect, vi } from 'vitest';
import SearchPage from './+page.svelte';
import { SearchService } from '$lib/services/SearchService';

vi.mock('$lib/services/SearchService');

describe('Search View Integration', () => {
    it('should bind input value to search query', async () => {
        render(SearchPage);
        const input = screen.getByPlaceholderText(/Search for datasets/i) as HTMLInputElement;
        
        await fireEvent.input(input, { target: { value: 'water quality' } });
        expect(input.value).toBe('water quality');
    });

    it('should show loading text when search button is clicked', async () => {
        // Delay the mock to capture the loading state
        (SearchService.searchDatasets as any).mockImplementation(() => 
            new Promise(resolve => setTimeout(() => resolve({ results: [] }), 100))
        );

        render(SearchPage);
        const input = screen.getByPlaceholderText(/Search for datasets/i);
        const button = screen.getByRole('button', { name: /Search/i });

        await fireEvent.input(input, { target: { value: 'river' } });
        await fireEvent.click(button);

        expect(screen.getByText('Searching...')).toBeInTheDocument();
    });

    it('should render results when service returns data', async () => {
        (SearchService.searchDatasets as any).mockResolvedValue({
            results: [{ id: '1', title: 'Unique Dataset Title', abstract: '...', authors: 'Admin', score: 1 }]
        });

        render(SearchPage);
        const button = screen.getByRole('button', { name: /Search/i });
        
        // Mock input
        const input = screen.getByPlaceholderText(/Search for datasets/i);
        await fireEvent.input(input, { target: { value: 'test' } });
        
        await fireEvent.click(button);

        // Check if the title appears in the list (DatasetCard should render this)
        const resultTitle = await screen.findByText('Unique Dataset Title');
        expect(resultTitle).toBeInTheDocument();
    });
});

```

---

### ðŸš€ Key Takeaways for your Report

* **Mocking Strategy:** We use `vi.mock` to prevent tests from hitting the C# backend. This makes tests fast and reliable for **GitHub Actions**.
* **Separation:** The Unit Test checks **logic** (Runes), while the Integration Test checks **DOM binding** (HTML/Events).
* **Tooling:** We use `vitest` as the runner and `jsdom` as the environment to simulate a browser in the terminal.

**Would you like me to help you set up a Playwright E2E test to verify that the frontend correctly talks to the actual C# backend through the proxy?**







