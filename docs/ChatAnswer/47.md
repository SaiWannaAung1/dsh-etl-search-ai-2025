Since we are following the **MVVM pattern** for your Svelte 5 Chat component, the testing strategy is split into two parts: **Unit Testing** the ViewModel (logic) and **Integration Testing** the View (UI interactions).

---

### 1. ViewModel Unit Test

**File:** `src/lib/viewmodels/ChatVM.test.ts`

This test focuses on the "Brain" of the chat. We use **Vitest** to ensure that messages are added correctly to the state and that the loading indicators (`isProcessing`) toggle appropriately.

```typescript
import { describe, it, expect, vi, beforeEach } from 'vitest';
import { ChatVM } from './ChatVM.svelte';
import { ChatService } from '$lib/services/ChatService';

// Mock the Service layer to avoid real API calls
vi.mock('$lib/services/ChatService');

describe('ChatVM Logic Tests', () => {
    let vm: ChatVM;

    beforeEach(() => {
        vm = new ChatVM();
        vi.clearAllMocks();
    });

    it('should initialize with an empty message list', () => {
        expect(vm.messages).toHaveLength(0);
        expect(vm.userInput).toBe('');
    });

    it('should add user message and clear input when sending', async () => {
        // Mock a successful API response
        (ChatService.askGemini as any).mockResolvedValue({ content: 'Hello! I am Gemini.' });

        vm.userInput = 'Hello AI';
        const sendTask = vm.sendMessage();

        // Check state immediately after calling (Optimistic UI)
        expect(vm.messages).toHaveLength(1);
        expect(vm.messages[0].content).toBe('Hello AI');
        expect(vm.userInput).toBe(''); // Input should be cleared
        expect(vm.isProcessing).toBe(true);

        await sendTask;

        // Check state after AI responds
        expect(vm.messages).toHaveLength(2);
        expect(vm.messages[1].role).toBe('assistant');
        expect(vm.isProcessing).toBe(false);
    });

    it('should not allow sending empty messages', async () => {
        vm.userInput = '   '; // Only whitespace
        await vm.sendMessage();

        expect(vm.messages).toHaveLength(0);
        expect(ChatService.askGemini).not.toHaveBeenCalled();
    });
});

```

---

### 2. View Integration Test

**File:** `src/routes/chat/ChatView.test.ts`

This test uses **Svelte Testing Library** to verify that the UI components (input, button, message bubbles) react correctly to the ViewModel.

```typescript
import { render, screen, fireEvent, cleanup } from '@testing-library/svelte';
import { describe, it, expect, vi, afterEach } from 'vitest';
import ChatPage from './+page.svelte';
import { ChatService } from '$lib/services/ChatService';

vi.mock('$lib/services/ChatService');

describe('Chat View Integration', () => {
    afterEach(() => cleanup());

    it('should render the chat input and send button', () => {
        render(ChatPage);
        expect(screen.getByPlaceholderText(/Ask about your datasets/i)).toBeInTheDocument();
        expect(screen.getByRole('button', { name: /Send/i })).toBeInTheDocument();
    });

    it('should disable the send button when input is empty', async () => {
        render(ChatPage);
        const button = screen.getByRole('button', { name: /Send/i }) as HTMLButtonElement;
        expect(button.disabled).toBe(true);

        const input = screen.getByPlaceholderText(/Ask about your datasets/i);
        await fireEvent.input(input, { target: { value: 'Looking for climate data' } });
        
        expect(button.disabled).toBe(false);
    });

    it('should display "thinking" indicator while processing', async () => {
        // Create a promise we can control
        let resolveApi: any;
        (ChatService.askGemini as any).mockReturnValue(new Promise((res) => {
            resolveApi = res;
        }));

        render(ChatPage);
        const input = screen.getByPlaceholderText(/Ask about your datasets/i);
        const button = screen.getByRole('button', { name: /Send/i });

        await fireEvent.input(input, { target: { value: 'How many datasets?' } });
        await fireEvent.click(button);

        // Verify the thinking text appears
        expect(screen.getByText(/Gemini is thinking/i)).toBeInTheDocument();

        // Resolve the API and verify it disappears
        resolveApi({ content: 'You have 50 datasets.' });
        await screen.findByText('You have 50 datasets.');
        expect(screen.queryByText(/Gemini is thinking/i)).not.toBeInTheDocument();
    });
});

```

---

### üìù Why this setup is perfect for Rider & GitHub Actions

1. **Fast Feedback:** These tests use `jsdom` (no browser needed), so they run in milliseconds in your Rider "Unit Tests" tool window.
2. **Logic/UI Separation:** If you decide to change your UI to a different CSS framework, your `ChatVM.test.ts` will still pass because the logic hasn't changed.
3. **Mocking:** By mocking `ChatService`, we ensure your GitHub Actions pipeline doesn't fail just because the Gemini API is down or your C# backend isn't running during the unit test phase.

**Would you like me to help you configure the `ChatService.ts` to include the specific error handling logic for when the LLM times out?**



