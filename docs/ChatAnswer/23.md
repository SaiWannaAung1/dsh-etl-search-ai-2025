```aiignore
You are absolutely right to be confused. In the Clean Architecture setup we created, the Program.cs is currently empty of logicâ€”it doesn't yet know about the SQLite database we just built in the Infrastructure layer.

We need to "wire up" the dependency injection. In .NET 8 Clean Architecture, we typically do this using an Extension Method to keep Program.cs clean.

Here is the implementation to fix this.

Step 1: Create the Dependency Injection Helper
We will use the file ServiceCollectionExtensions.cs to tell the API how to build the IMetadataRepository.

File: backend/DshEtlSearch.Api/Configuration/ServiceCollectionExtensions.cs

using DshEtlSearch.Core.Interfaces.Infrastructure;
using DshEtlSearch.Infrastructure.Data.SQLite;
using Microsoft.EntityFrameworkCore;

namespace DshEtlSearch.Api.Configuration
{
    public static class ServiceCollectionExtensions
    {
        public static IServiceCollection AddInfrastructureServices(this IServiceCollection services, IConfiguration configuration)
        {
            // 1. Read Connection String from appsettings.json
            var connectionString = configuration.GetConnectionString("DefaultConnection") 
                                   ?? "Data Source=dsh-metadata.db";

            // 2. Register Entity Framework Core (SQLite)
            services.AddDbContext<AppDbContext>(options =>
                options.UseSqlite(connectionString));

            // 3. Register the Repository Implementation
            // "When anyone asks for IMetadataRepository, give them SqliteMetadataRepository"
            services.AddScoped<IMetadataRepository, SqliteMetadataRepository>();

            return services;
        }
    }
}
Step 2: Update Program.cs to Use It
Now we simply call that method in Program.cs. This makes the "Entry Point" clean and readable.

File: backend/DshEtlSearch.Api/Program.cs

using DshEtlSearch.Api.Configuration;
using DshEtlSearch.Infrastructure.Data.SQLite; // Needed for database migration logic

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddControllers();
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

// [CRITICAL] Register our custom Infrastructure (Database, etc.)
builder.Services.AddInfrastructureServices(builder.Configuration);

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

// [OPTIONAL] Auto-create database on startup (Great for Dev, dangerous for Prod)
using (var scope = app.Services.CreateScope())
{
    var dbContext = scope.ServiceProvider.GetRequiredService<AppDbContext>();
    // This creates the .db file if it doesn't exist
    dbContext.Database.EnsureCreated();
}

app.UseHttpsRedirection();
app.UseAuthorization();
app.MapControllers();

app.Run();
Step 3: Define the Connection String
Finally, tell the application where to save the file.

File: backend/DshEtlSearch.Api/appsettings.json

{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },
  "AllowedHosts": "*",
  "ConnectionStrings": {
    "DefaultConnection": "Data Source=dsh-metadata.db"
  }
}
Summary of what we just did
    ServiceCollectionExtensions.cs: Defined the logic: "Use SQLite with this connection string."
    Program.cs: Called that logic on startup.
    appsettings.json: Provided the filename (dsh-metadata.db).
Now, if you were to run the API (dotnet run --project backend/DshEtlSearch.Api), it would successfully create the dsh-metadata.db file in your project folder.
```