```aiignore
Based on your detailed requirements and the specific URL patterns provided, you need to implement a dedicated CehCatalogueClient to encapsulate this logic.

This should be implemented Right Now (as Task 1.4b), before the ETL Orchestrator (Task 1.5).

The Orchestrator shouldn't know how to construct a URL (e.g., ?format=json vs /gemini/waf/). It should simply ask the client: "Give me the metadata for ID X" or "Give me the dataset zip for ID Y."

Revised Implementation Plan for Sprint 1
Task 1.4a (Done): Generic Zip Extraction.
Task 1.4b (New - THIS STEP): Implement CEH Catalogue Client.
Goal: abstract the complex URL logic (waf, format=json, data-package).
Input: A FileIdentifier (string).
Output: Streams for Metadata (XML/JSON) and Data (Zip).
Task 1.5: Update Orchestrator to use this new Client.
Step 1: Define the Interface (Core Layer)
We need a contract that describes what operations are available without exposing the messy URL patterns.

File: DshEtlSearch.Core/Interfaces/Infrastructure/ICehCatalogueClient.cs

using DshEtlSearch.Core.Common;
using DshEtlSearch.Core.Common.Enums;

namespace DshEtlSearch.Core.Interfaces.Infrastructure;

public interface ICehCatalogueClient
{
    /// <summary>
    /// Fetches the metadata document for a specific dataset ID in the requested format.
    /// URL Pattern 1 (ISO): /documents/gemini/waf/{id}.xml
    /// URL Pattern 2 (JSON): /documents/{id}?format=json
    /// </summary>
    Task<Result<Stream>> GetMetadataAsync(string fileIdentifier, MetadataFormat format);

    /// <summary>
    /// Downloads the main dataset package (Zip).
    /// URL Pattern: https://data-package.ceh.ac.uk/data/{id}.zip
    /// </summary>
    Task<Result<Stream>> DownloadDatasetZipAsync(string fileIdentifier);

    /// <summary>
    /// Downloads only the supporting documents (if available separately).
    /// </summary>
    Task<Result<Stream>> DownloadSupportingDocsAsync(string fileIdentifier);
}
Step 2: Implement the Client (Infrastructure Layer)
This class handles the specific URL construction rules you provided. It separates the Metadata access (Catalogue) from the Data access (Data Package).

File: DshEtlSearch.Infrastructure/ExternalServices/Ceh/CehCatalogueClient.cs

using DshEtlSearch.Core.Common;
using DshEtlSearch.Core.Common.Enums;
using DshEtlSearch.Core.Interfaces.Infrastructure;

namespace DshEtlSearch.Infrastructure.ExternalServices.Ceh;

public class CehCatalogueClient : ICehCatalogueClient
{
    private readonly HttpClient _httpClient;
    
    // Base URLs
    private const string CatalogueBaseUrl = "https://catalogue.ceh.ac.uk";
    private const string DataPackageBaseUrl = "https://data-package.ceh.ac.uk";

    public CehCatalogueClient(HttpClient httpClient)
    {
        _httpClient = httpClient;
        _httpClient.DefaultRequestHeaders.UserAgent.ParseAdd("DshEtlSearch-Bot/1.0");
    }

    public async Task<Result<Stream>> GetMetadataAsync(string fileIdentifier, MetadataFormat format)
    {
        string url = BuildMetadataUrl(fileIdentifier, format);
        return await DownloadStreamAsync(url);
    }

    public async Task<Result<Stream>> DownloadDatasetZipAsync(string fileIdentifier)
    {
        // Pattern: https://data-package.ceh.ac.uk/data/{id}.zip
        string url = $"{DataPackageBaseUrl}/data/{fileIdentifier}.zip";
        return await DownloadStreamAsync(url);
    }
    
    public async Task<Result<Stream>> DownloadSupportingDocsAsync(string fileIdentifier)
    {
        // Based on typical CEH patterns, supporting docs are often at /documents/{id}/supporting-documents
        // However, if the prompt implies they are inside the main zip, we might not need this.
        // If they are separate:
        string url = $"{CatalogueBaseUrl}/documents/{fileIdentifier}/supporting-documents"; 
        return await DownloadStreamAsync(url);
    }

    private string BuildMetadataUrl(string id, MetadataFormat format)
    {
        return format switch
        {
            // XML is in the WAF folder
            MetadataFormat.Iso19115Xml => $"{CatalogueBaseUrl}/documents/gemini/waf/{id}.xml",
            
            // Others use the ?format= query param
            MetadataFormat.JsonExpanded => $"{CatalogueBaseUrl}/documents/{id}?format=json",
            MetadataFormat.SchemaOrgJsonLd => $"{CatalogueBaseUrl}/documents/{id}?format=schema.org",
            MetadataFormat.RdfTurtle => $"{CatalogueBaseUrl}/documents/{id}?format=ttl",
            
            _ => throw new ArgumentException($"Unsupported format: {format}")
        };
    }

    private async Task<Result<Stream>> DownloadStreamAsync(string url)
    {
        try
        {
            // Use ResponseHeadersRead to avoid loading huge files into memory immediately
            var response = await _httpClient.GetAsync(url, HttpCompletionOption.ResponseHeadersRead);
            
            if (!response.IsSuccessStatusCode)
            {
                return Result<Stream>.Failure($"Failed to fetch {url}. Status: {response.StatusCode}");
            }

            var stream = await response.Content.ReadAsStreamAsync();
            return Result<Stream>.Success(stream);
        }
        catch (Exception ex)
        {
            return Result<Stream>.Failure($"Network error accessing {url}: {ex.Message}");
        }
    }
}
Step 3: Update EtlOrchestrator to Use It
Now we update Task 1.5 (The Orchestrator). Instead of generic generic downloading, it now specifically asks for the XML first (to get the title/abstract), then the Zip (to get the files).

Updated File: DshEtlSearch.Core/Features/Ingestion/EtlOrchestrator.cs (Partial Update)

public class EtlOrchestrator : IEtlService
{
    private readonly ICehCatalogueClient _cehClient; // Changed from IDatasetDownloader
    private readonly IArchiveProcessor _archiveProcessor;
    private readonly IMetadataRepository _repository;
    private readonly MetadataParserFactory _parserFactory;

    public EtlOrchestrator(
        ICehCatalogueClient cehClient, // Inject the new smart client
        IArchiveProcessor archiveProcessor,
        IMetadataRepository repository,
        MetadataParserFactory parserFactory)
    {
        _cehClient = cehClient;
        // ... assignments
    }

    public async Task<Result> IngestDatasetAsync(string fileIdentifier)
    {
        // 1. Fetch Metadata (XML) directly from WAF
        var metaResult = await _cehClient.GetMetadataAsync(fileIdentifier, MetadataFormat.Iso19115Xml);
        if (!metaResult.IsSuccess) return Result.Failure("Metadata not found");

        // 2. Parse Metadata
        var parser = _parserFactory.GetParser(MetadataFormat.Iso19115Xml);
        var parseResult = parser.Parse(metaResult.Value!, Guid.Empty); // Temporary Guid
        if (!parseResult.IsSuccess) return Result.Failure("Failed to parse XML");

        var metadataRecord = parseResult.Value!;

        // 3. Create Dataset Entity
        var dataset = new Dataset(fileIdentifier);
        dataset.Metadata = metadataRecord;

        // 4. Download Data Package (ZIP)
        var zipResult = await _cehClient.DownloadDatasetZipAsync(fileIdentifier);
        if (zipResult.IsSuccess)
        {
            // Extract supporting docs from the Zip
            var extractResult = await _archiveProcessor.ExtractDocumentsAsync(zipResult.Value!, dataset.Id);
            if (extractResult.IsSuccess)
            {
                foreach(var doc in extractResult.Value!) dataset.AddDocument(doc);
            }
        }
        else 
        {
            // Fallback: If zip download fails, maybe it's a "fileAccess" type?
            // TODO: Implement logic to check 'fileAccess' vs 'download' inside metadataRecord
        }

        // 5. Save to DB
        await _repository.AddAsync(dataset);
        
        return Result.Success();
    }
}
Key Takeaway for your implementation:
You must implement CehCatalogueClient now. It encapsulates the complexity of the CEH URL structures so your main business logic remains clean and readable.
```