```aiignore
This is a critical component of the "Ingestion" engine. We will use the Strategy Pattern here. This allows the system to select the correct parsing algorithm at runtime without modifying the core logic (Open/Closed Principle).

Step 1: Create the Branch
Run this in your terminal:

git checkout develop
git checkout -b feature/parsing-strategies
Step 2: Define the Strategy Interface
We need a unified contract. Every parser must take a raw stream and return our standardized MetadataRecord.

File: backend/DshEtlSearch.Core/Interfaces/Infrastructure/IMetadataParser.cs (If this file exists, ensure it matches this signature. Note the use of Result<T> for error handling.)

using DshEtlSearch.Core.Common;
using DshEtlSearch.Core.Domain;

namespace DshEtlSearch.Core.Interfaces.Infrastructure
{
    public interface IMetadataParser
    {
        /// <summary>
        /// Parses a raw data stream into a standardized MetadataRecord.
        /// </summary>
        /// <param name="content">The file stream (XML, JSON, etc.)</param>
        /// <returns>A Result containing the parsed record or an error message.</returns>
        Task<Result<MetadataRecord>> ParseAsync(Stream content);
    }
}
Step 3: Implement Strategy 1 - ISO 19115 (XML)
This uses System.Xml.Linq (XDocument) to traverse standard geographic metadata XMLs.

File: backend/DshEtlSearch.Infrastructure/FileProcessing/Parsers/Strategies/Iso19115XmlParser.cs

using System.Xml.Linq;
using DshEtlSearch.Core.Common;
using DshEtlSearch.Core.Common.Enums;
using DshEtlSearch.Core.Domain;
using DshEtlSearch.Core.Interfaces.Infrastructure;

namespace DshEtlSearch.Infrastructure.FileProcessing.Parsers.Strategies
{
    public class Iso19115XmlParser : IMetadataParser
    {
        public async Task<Result<MetadataRecord>> ParseAsync(Stream content)
        {
            try
            {
                // Load XML asynchronously
                var xdoc = await XDocument.LoadAsync(content, LoadOptions.None, CancellationToken.None);
                
                // Define Namespaces typically found in ISO 19115
                XNamespace gmd = "http://www.isotc211.org/2005/gmd";
                XNamespace gco = "http://www.isotc211.org/2005/gco";

                // Extract Title (Defensive coding with null coalescing)
                var title = xdoc.Descendants(gmd + "title")
                                .Descendants(gco + "CharacterString")
                                .FirstOrDefault()?.Value 
                            ?? "Untitled Dataset";

                // Extract Abstract
                var abstractText = xdoc.Descendants(gmd + "abstract")
                                       .Descendants(gco + "CharacterString")
                                       .FirstOrDefault()?.Value;

                // Create Record
                var record = new MetadataRecord
                {
                    Title = title,
                    Abstract = abstractText,
                    SourceFormat = MetadataFormat.Iso19115Xml,
                    Authors = "Unknown", // XML parsing for authors is complex; simplified for MVP
                    Keywords = "iso, geospatial"
                };

                return Result<MetadataRecord>.Success(record);
            }
            catch (Exception ex)
            {
                return Result<MetadataRecord>.Failure($"Failed to parse ISO XML: {ex.Message}");
            }
        }
    }
}
Step 4: Implement Strategy 2 - JSON Expanded
This handles the custom internal JSON format. We use System.Text.Json.

File: backend/DshEtlSearch.Infrastructure/FileProcessing/Parsers/Strategies/JsonExpandedParser.cs

using System.Text.Json;
using DshEtlSearch.Core.Common;
using DshEtlSearch.Core.Common.Enums;
using DshEtlSearch.Core.Domain;
using DshEtlSearch.Core.Interfaces.Infrastructure;

namespace DshEtlSearch.Infrastructure.FileProcessing.Parsers.Strategies
{
    public class JsonExpandedParser : IMetadataParser
    {
        public async Task<Result<MetadataRecord>> ParseAsync(Stream content)
        {
            try
            {
                var options = new JsonSerializerOptions { PropertyNameCaseInsensitive = true };
                var doc = await JsonSerializer.DeserializeAsync<JsonElement>(content, options);

                // Check specific JSON structure (Accessing properties safely)
                string title = doc.TryGetProperty("name", out var nameProp) ? nameProp.GetString() ?? "No Title" : "No Title";
                string description = doc.TryGetProperty("description", out var descProp) ? descProp.GetString() : null;
                
                var record = new MetadataRecord
                {
                    Title = title,
                    Abstract = description,
                    SourceFormat = MetadataFormat.JsonExpanded,
                    Authors = "System Generated"
                };

                return Result<MetadataRecord>.Success(record);
            }
            catch (Exception ex)
            {
                return Result<MetadataRecord>.Failure($"Failed to parse Expanded JSON: {ex.Message}");
            }
        }
    }
}
Step 5: Implement Strategy 3 - Schema.org (JSON-LD)
This looks for the @context and @type fields standard in JSON-LD.

File: backend/DshEtlSearch.Infrastructure/FileProcessing/Parsers/Strategies/SchemaOrgJsonLdParser.cs

using System.Text.Json;
using DshEtlSearch.Core.Common;
using DshEtlSearch.Core.Common.Enums;
using DshEtlSearch.Core.Domain;
using DshEtlSearch.Core.Interfaces.Infrastructure;

namespace DshEtlSearch.Infrastructure.FileProcessing.Parsers.Strategies
{
    public class SchemaOrgJsonLdParser : IMetadataParser
    {
        public async Task<Result<MetadataRecord>> ParseAsync(Stream content)
        {
            try
            {
                var doc = await JsonSerializer.DeserializeAsync<JsonElement>(content);

                // Basic JSON-LD Validation
                if (!doc.TryGetProperty("@context", out _) || !doc.TryGetProperty("@type", out _))
                {
                    return Result<MetadataRecord>.Failure("Invalid JSON-LD: Missing @context or @type");
                }

                string title = doc.TryGetProperty("name", out var n) ? n.GetString() ?? "No Name" : "No Name";
                string description = doc.TryGetProperty("description", out var d) ? d.GetString() : null;
                string keywords = doc.TryGetProperty("keywords", out var k) ? k.GetString() : null;

                var record = new MetadataRecord
                {
                    Title = title,
                    Abstract = description,
                    Keywords = keywords,
                    SourceFormat = MetadataFormat.SchemaOrgJsonLd
                };

                return Result<MetadataRecord>.Success(record);
            }
            catch (Exception ex)
            {
                return Result<MetadataRecord>.Failure($"JSON-LD Error: {ex.Message}");
            }
        }
    }
}
Step 6: Implement Strategy 4 - RDF (Turtle)
Note: A full Turtle parser is complex. For this MVP, we will use a simple text-based extraction (Regex) to avoid heavy dependencies like dotNetRDF unless requested.

File: backend/DshEtlSearch.Infrastructure/FileProcessing/Parsers/Strategies/RdfTurtleParser.cs

using System.Text.RegularExpressions;
using DshEtlSearch.Core.Common;
using DshEtlSearch.Core.Common.Enums;
using DshEtlSearch.Core.Domain;
using DshEtlSearch.Core.Interfaces.Infrastructure;

namespace DshEtlSearch.Infrastructure.FileProcessing.Parsers.Strategies
{
    public class RdfTurtleParser : IMetadataParser
    {
        public async Task<Result<MetadataRecord>> ParseAsync(Stream content)
        {
            try
            {
                using var reader = new StreamReader(content);
                var text = await reader.ReadToEndAsync();

                // Simple Regex to find Dublin Core Title (dct:title "Some Title")
                var titleMatch = Regex.Match(text, @"dct:title\s+""(.*?)""");
                var descMatch = Regex.Match(text, @"dct:description\s+""(.*?)""");

                var record = new MetadataRecord
                {
                    Title = titleMatch.Success ? titleMatch.Groups[1].Value : "Unknown RDF Dataset",
                    Abstract = descMatch.Success ? descMatch.Groups[1].Value : null,
                    SourceFormat = MetadataFormat.RdfTurtle
                };

                return Result<MetadataRecord>.Success(record);
            }
            catch (Exception ex)
            {
                return Result<MetadataRecord>.Failure($"RDF Parse Error: {ex.Message}");
            }
        }
    }
}
Step 7: The Factory (The Decision Maker)
This Factory encapsulates the creation logic. It adheres to the Single Responsibility Principle: "I only decide which parser to build."

File: backend/DshEtlSearch.Infrastructure/FileProcessing/Parsers/MetadataParserFactory.cs

using DshEtlSearch.Core.Common.Enums;
using DshEtlSearch.Core.Interfaces.Infrastructure;
using DshEtlSearch.Infrastructure.FileProcessing.Parsers.Strategies;

namespace DshEtlSearch.Infrastructure.FileProcessing.Parsers
{
    public class MetadataParserFactory
    {
        // In a real DI scenario, we might inject IServiceProvider, 
        // but for simplicity and clarity, we instantiate strategies here.
        
        public IMetadataParser GetParser(MetadataFormat format)
        {
            return format switch
            {
                MetadataFormat.Iso19115Xml => new Iso19115XmlParser(),
                MetadataFormat.JsonExpanded => new JsonExpandedParser(),
                MetadataFormat.SchemaOrgJsonLd => new SchemaOrgJsonLdParser(),
                MetadataFormat.RdfTurtle => new RdfTurtleParser(),
                _ => throw new ArgumentException($"No parser strategy found for format: {format}")
            };
        }
    }
}
Step 8: Unit Tests (Critical)
We must ensure each strategy handles its format correctly.

File: backend/DshEtlSearch.UnitTests/Infrastructure/Parsers/ParserStrategiesTests.cs

using System.Text;
using DshEtlSearch.Core.Common.Enums;
using DshEtlSearch.Infrastructure.FileProcessing.Parsers;
using DshEtlSearch.Infrastructure.FileProcessing.Parsers.Strategies;
using FluentAssertions;
using Xunit;

namespace DshEtlSearch.UnitTests.Infrastructure.Parsers
{
    public class ParserStrategiesTests
    {
        private Stream StringToStream(string text)
        {
            return new MemoryStream(Encoding.UTF8.GetBytes(text));
        }

        [Fact]
        public async Task IsoXmlParser_ShouldExtractTitle_FromValidXml()
        {
            // Arrange
            var xml = @"<?xml version='1.0'?>
                        <gmd:MD_Metadata xmlns:gmd='http://www.isotc211.org/2005/gmd' xmlns:gco='http://www.isotc211.org/2005/gco'>
                            <gmd:identificationInfo>
                                <gmd:title>
                                    <gco:CharacterString>ISO Test Title</gco:CharacterString>
                                </gmd:title>
                            </gmd:identificationInfo>
                        </gmd:MD_Metadata>";
            var parser = new Iso19115XmlParser();

            // Act
            var result = await parser.ParseAsync(StringToStream(xml));

            // Assert
            result.IsSuccess.Should().BeTrue();
            result.Value!.Title.Should().Be("ISO Test Title");
            result.Value.SourceFormat.Should().Be(MetadataFormat.Iso19115Xml);
        }

        [Fact]
        public async Task JsonExpandedParser_ShouldExtractName()
        {
            // Arrange
            var json = @"{ ""name"": ""Expanded JSON Title"", ""description"": ""A test description"" }";
            var parser = new JsonExpandedParser();

            // Act
            var result = await parser.ParseAsync(StringToStream(json));

            // Assert
            result.IsSuccess.Should().BeTrue();
            result.Value!.Title.Should().Be("Expanded JSON Title");
        }

        [Fact]
        public async Task Factory_ShouldReturnCorrectParser()
        {
            // Arrange
            var factory = new MetadataParserFactory();

            // Act & Assert
            factory.GetParser(MetadataFormat.Iso19115Xml).Should().BeOfType<Iso19115XmlParser>();
            factory.GetParser(MetadataFormat.RdfTurtle).Should().BeOfType<RdfTurtleParser>();
        }
    }
}
Next Steps
Run the tests: dotnet test ./backend/DshEtlSearch.UnitTests/DshEtlSearch.UnitTests.csproj
Commit and Push:
    git add .
    git commit -m "feat: implement strategy pattern for metadata parsers"
    git push origin feature/parsing-strategies
Ready to proceed?
```