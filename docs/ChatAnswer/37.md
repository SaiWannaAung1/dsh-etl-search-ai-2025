```aiignore

To implement the search functionality correctly, we need to bridge your Vector Store (where the .docx and .pdf snippets are) with your SQL Database (where the dataset titles and authors are).

Below are the three files needed to complete this feature, following your requested folder structure.

1. The Request Model
Location: DshEtlSearch.Api/Models/Requests/SearchRequest.cs

namespace DshEtlSearch.Api.Models.Requests;

public class SearchRequest
{
    public string Query { get; set; } = string.Empty;
    public int Limit { get; set; } = 5;
}
2. The Response Model
Location: DshEtlSearch.Api/Models/Responses/SearchResponse.cs

namespace DshEtlSearch.Api.Models.Responses;

public class SearchResponse
{
    public Guid DatasetId { get; set; }
    public string Title { get; set; } = string.Empty;
    public string FileName { get; set; } = string.Empty;
    
    // This contains the 200-word snippet from the DOCX or PDF
    public string Snippet { get; set; } = string.Empty;
    
    // Similarity score (relevance)
    public float Score { get; set; }
}
3. The Search Controller
Location: DshEtlSearch.Api/Controllers/SearchController.cs

This controller uses the OnnxEmbeddingService to turn the user's question into a vector, then queries Qdrant to find the matching chunks extracted from your documents.

using DshEtlSearch.Api.Models.Requests;
using DshEtlSearch.Api.Models.Responses;
using DshEtlSearch.Core.Interfaces.Infrastructure;
using DshEtlSearch.Core.Interfaces.Services;
using Microsoft.AspNetCore.Mvc;

namespace DshEtlSearch.Api.Controllers;

[ApiController]
[Route("api/[controller]")]
public class SearchController : ControllerBase
{
    private readonly IEmbeddingService _embeddingService;
    private readonly IVectorStore _vectorStore;
    private readonly IMetadataRepository _repository;
    private readonly ILogger<SearchController> _logger;

    private const string CollectionName = "research_data";

    public SearchController(
        IEmbeddingService embeddingService,
        IVectorStore vectorStore,
        IMetadataRepository repository,
        ILogger<SearchController> logger)
    {
        _embeddingService = embeddingService;
        _vectorStore = vectorStore;
        _repository = repository;
        _logger = logger;
    }

    [HttpPost]
    public async Task<ActionResult<List<SearchResponse>>> Search([FromBody] SearchRequest request)
    {
        if (string.IsNullOrWhiteSpace(request.Query))
            return BadRequest("Query cannot be empty.");

        try
        {
            // 1. Convert user's search text into a vector
            var vectorResult = await _embeddingService.GenerateEmbeddingAsync(request.Query);
            if (!vectorResult.IsSuccess)
                return StatusCode(500, "Embedding generation failed.");

            // 2. Perform the search in Qdrant
            var results = await _vectorStore.SearchAsync(
                CollectionName, 
                vectorResult.Value!, 
                request.Limit
            );

            var responseList = new List<SearchResponse>();

            // 3. Enrich the results with SQL metadata
            foreach (var hit in results)
            {
                // Fetch the dataset details (Title, etc) from SQL using the SourceId
                var dataset = await _repository.GetByIdAsync(hit.SourceId);
                
                responseList.Add(new SearchResponse
                {
                    DatasetId = hit.SourceId,
                    Title = dataset?.Title ?? "Unknown Dataset",
                    Snippet = hit.TextContent, // The text we extracted from the ZIP/DOCX
                    Score = 0.0f, // Note: To show the score, we'd need a Result DTO
                    FileName = "Supporting Document" 
                });
            }

            return Ok(responseList);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "Search failed for query: {Query}", request.Query);
            return StatusCode(500, "Internal search error.");
        }
    }
}
Critical Refinement for your IVectorStore
In your previous QdrantVectorStore implementation, you returned List<EmbeddingVector>. However, search results usually require the Similarity Score (how close the match is).

Since EmbeddingVector is a domain entity, it usually doesn't have a Score property. I recommend creating a small DTO in your Core layer:

DshEtlSearch.Core/Common/VectorSearchResult.cs

namespace DshEtlSearch.Core.Common;

public class VectorSearchResult
{
    public Guid SourceId { get; set; }
    public string TextContent { get; set; } = string.Empty;
    public float Score { get; set; } // <--- This is vital for the UI
}
Would you like me to rewrite the SearchAsync method in your QdrantVectorStore to use this new VectorSearchResult so you can show the relevance score in the search results?


```